# ALGORISMフォルダ内　各プログラムまとめ

---

**<details><summary>orderフォルダ内 各プログラムまとめ</summary>**

## code2-1.cpp

**内容・動作**
- 1000万回のループでカウンタをインクリメントし、ループ回数と実行時間を計測・出力。

**オーダー**
- $O(N)$（N回の単純なループ）

**検証結果例**
- count: 10000000
- 実行時間: 実行環境による（例: 数秒）

---

## code2-2.cpp

**内容・動作**
- 10000×10000回の2重ループでカウンタをインクリメントし、ループ回数と実行時間を計測・出力。

**オーダー**
- $O(N^2)$（2重ループ）

**検証結果例**
- count: 100000000
- 実行時間: $O(N^2)$ なので、code2-1.cppより大幅に長い

---

## code2-3.cpp

**内容・動作**
- 2からN（100）までの偶数を順に出力し、実行時間を計測・出力。

**オーダー**
- $O(N)$（N/2回のループ）

**検証結果例**
- 2, 4, 6, ..., 100 が出力される
- 実行時間: 非常に短い

---

## code2-4.cpp

**内容・動作**
- N=10000個の点（座標は未初期化）から、2点間のユークリッド距離の最小値を全探索で求める。
- 2重ループで全ての点の組み合わせを調べ、最小距離を更新。
- 最小距離と実行時間を出力。

**オーダー**
- $O(N^2)$（全ての点のペアを調べるため）

**検証結果例**
- 最小距離: 入力値による（座標が未初期化なので0になる可能性あり）
- 実行時間: 非常に長い（$O(N^2)$）

---

## まとめ表

| ファイル名      | 内容・動作                           | オーダー   | 検証結果例（出力）         |
|----------------|--------------------------------------|------------|----------------------------|
| code2-1.cpp    | N回ループでカウント                  | $O(N)$       | count: 10000000, 実行時間  |
| code2-2.cpp    | N×N回2重ループでカウント             | $O(N^2)$     | count: 100000000, 実行時間 |
| code2-3.cpp    | 2～Nまでの偶数出力                   | $O(N)$       | 2,4,6,...,100, 実行時間    |
| code2-4.cpp    | N点間の最小距離を全探索              | $O(N^2)$     | 最小距離, 実行時間         |

</details>


**<details><summary>recursiveフォルダ内 各プログラムまとめ</summary>**

## code4-2.cpp

**内容・動作**
- 再帰的に1からNまでの合計を計算する関数funcを実装。
- func(20)を呼び出し、各段階のNと合計値を出力。
- 実行時間も計測。

**オーダー**
- $O(N)$（N回の再帰呼び出し）

**検証結果例**
- N=20のとき合計210
- 実行時間: 非常に短い

---

## code4-4.cpp

**内容・動作**
- 2つの整数m, nの最大公約数（GCD）をユークリッドの互除法で再帰的に計算。
- GCD(51, 15)やGCD(15, 51)を計算し出力。
- 実行時間も計測。

**オーダー**
- $O(log max(m, n))$（ユークリッドの互除法の計算量）

**検証結果例**
- GCD(51, 15) → 3
- GCD(15, 51) → 3
- 実行時間: 非常に短い

---

## code4-6.cpp

**内容・動作**
- フィボナッチ数列の第N項を再帰的に計算する関数fiboを実装。
- fibo(6)を呼び出し、各段階のNと計算結果を出力。
- 実行時間も計測。

**オーダー**
- $O(2^N)$（指数時間、重複計算あり）

**検証結果例**
- fibo(6) → 8
- 実行時間: Nが大きいと急激に増加

---

## code4-7.cpp

**内容・動作**
- フィボナッチ数列を配列で管理し、for文で第49項まで計算。
- 各項の値を出力。
- 実行時間も計測。

**オーダー**
- $O(N)$（ループのみ）

**検証結果例**
- F[49] → 7778742049
- 実行時間: 非常に短い

---

## code4-8.cpp

**内容・動作**
- メモ化再帰を用いてフィボナッチ数列の第N項を計算。
- fibo(49)を呼び出し、計算済み値は配列memoに保存。
- 各項の値と実行時間を出力。

**オーダー**
- $O(N)$（メモ化により重複計算なし）

**検証結果例**
- F[49] → 7778742049
- 実行時間: 非常に短い

---

## まとめ表

| ファイル名      | 内容・動作                                 | オーダー         | 検証結果例                      |
|----------------|--------------------------------------------|------------------|---------------------------------|
| code4-2.cpp    | 再帰で1～Nの合計                           | $O(N)$             | 合計, 実行時間                  |
| code4-4.cpp    | 再帰で最大公約数（ユークリッドの互除法）    | $O(log N)$          | GCD, 実行時間                   |
| code4-6.cpp    | 再帰でフィボナッチ数列                     | $O(2^N)$            | 第N項, 実行時間                 |
| code4-7.cpp    | 配列とループでフィボナッチ数列              | $O(N)$              | 第N項, 実行時間                 |
| code4-8.cpp    | メモ化再帰でフィボナッチ数列                | $O(N)$              | 第N項, 実行時間                 |

</details>


**<details><summary>brute-forceフォルダ内 各プログラムまとめ</summary>**

## code3-1.cpp

**内容・動作**
- 配列a（要素数100万）に0～N-1を格納。
- 線形探索で値v（0）が存在するか調べる。
- 結果と実行時間を出力。

**オーダー**
- $O(N)$（最悪N回の比較）

**検証結果例**
- 「値 0 は配列に存在します。」
- 実行時間: 数ミリ秒程度

---

## code3-2.cpp

**内容・動作**
- 配列a（要素数100万）に0～N-1を格納。
- 線形探索で値v（999999）が存在するインデックスを調べる。
- 結果（インデックス）と実行時間を出力。

**オーダー**
- $O(N)$（最悪N回の比較）

**検証結果例**
- 999999
- 実行時間: 数ミリ秒～数十ミリ秒

---

## code3-3.cpp

**内容・動作**
- 配列a（要素数100万）に0～N-1を格納。
- 線形探索で配列aの最小値を求める。
- 最小値と実行時間を出力。

**オーダー**
- $O(N)$（N回の比較）

**検証結果例**
- 最小値: 0
- 実行時間: 数ミリ秒～数十ミリ秒

---

## code3-4.cpp

**内容・動作**
- 配列a, b（要素数10万）に0～N-1を格納。
- 2重ループでa[i]+b[j]がK（100）以上となる最小値を探索。
- 最小値と実行時間を出力。

**オーダー**
- $O(N^2)$（2重ループ）

**検証結果例**
- 最小値: 100
- 実行時間: 数秒～十数秒

---

## code3-5.txt

**内容・動作**
- ビット全探索のif-else構造の雛形。

---

## code3-6.cpp

**内容・動作**
- 配列a（要素数11）に0～N-1を格納。
- ビット全探索で部分集合の和がW（55）となるものが存在するか判定。
- 結果と実行時間を出力。

**オーダー**
- $O(2^N * N)$（全部分集合を調べる）

**検証結果例**
- 「合計 55 を作る部分集合が存在します。」
- 実行時間: 数ミリ秒～数秒

---

## まとめ表

| ファイル名      | 内容・動作                                 | オーダー         | 検証結果例                      |
|----------------|--------------------------------------------|------------------|---------------------------------|
| code3-1.cpp    | 線形探索で値の存在判定                     | $O(N)$             | 存在有無, 実行時間              |
| code3-2.cpp    | 線形探索で値のインデックス判定             | $O(N)$             | インデックス, 実行時間          |
| code3-3.cpp    | 線形探索で配列の最小値探索                 | $O(N)$             | 最小値, 実行時間                |
| code3-4.cpp    | 2重ループで条件を満たす最小値探索          | $O(N^2)$           | 最小値, 実行時間                |
| code3-5.txt    | ビット全探索のif-else雛形                  | -                | -                               |
| code3-6.cpp    | ビット全探索で部分和問題                   | $O(2^N * N)$       | 存在有無, 実行時間              |

</details>


**<details><summary>binaryフォルダ内 各プログラムまとめ</summary>**

## code6-1.cpp

**内容・動作**
- 昇順ソート済み配列a（{3, 5, 8, 10, 14, 17, 21, 39}）に対して、二分探索（バイナリサーチ）で指定した値のインデックスを返す。
- 存在しない値の場合は-1を返す。
- いくつかのテストケースで動作を確認し、結果を出力。

**オーダー**
- $O(log N)$（二分探索のため）

**検証結果例**
- binary_search(10) → 3
- binary_search(3) → 0
- binary_search(39) → 7
- binary_search(-100) → -1
- binary_search(9) → -1
- binary_search(100) → -1

---

## まとめ表

| ファイル名      | 内容・動作                         | オーダー   | 検証結果例（出力）         |
|----------------|------------------------------------|------------|----------------------------|
| code6-1.cpp    | 二分探索で値のインデックス判定     | $O(log N)$   | 3, 0, 7, -1, -1, -1        |

</details>


**<details><summary>array_linklist_hashtableフォルダ内 各プログラムまとめ</summary>**

## code8-1.cpp

**内容・動作**
- 10個の整数を持つ配列aを初期化。
- a[0]・a[2]の出力、a[2]の値の書き換えと再出力。

**オーダー**
- $O(1)$（配列アクセス・書き換え）

**検証結果例**
- 4
- 12
- 5

---

## code8-2.txt

**内容・動作**
- 単方向リスト用のNode構造体の定義。

---

## code8-3.txt

**内容・動作**
- 単方向リストへのノード挿入関数の定義。

---

## code8-4.cpp

**内容・動作**
- 番兵ノードを使った単方向連結リストの実装。
- 先頭への挿入・リスト内容の出力。
- namesリストの各要素を順に挿入し、各ステップでリストを出力。

**オーダー**
- 挿入: $O(1)$／出力: $O(N)$

**検証結果例**
- 各ステップでリストの状態が出力される

---

## code8-5.txt

**内容・動作**
- 双方向リスト用のNode構造体の定義。

---

## code8-6.cpp

**内容・動作**
- 番兵ノードを使った双方向連結リストの実装。
- 先頭への挿入・リスト内容の出力・ノード削除。

**オーダー**
- 挿入/削除: $O(1)$／出力: $O(N)$

**検証結果例**
- 挿入・削除後のリスト状態が出力される

---

## code8-7.txt

**内容・動作**
- C++のsetやunordered_setの基本操作例（挿入・削除・存在判定）。

---

## まとめ表

| ファイル名      | 内容・動作                                 | オーダー         | 検証結果例                      |
|----------------|--------------------------------------------|------------------|---------------------------------|
| code8-1.cpp    | 配列の初期化・アクセス・書き換え            | $O(1)$             | 値の出力                        |
| code8-2.txt    | 単方向リストのノード定義                    | -                | -                               |
| code8-3.txt    | 単方向リストへのノード挿入関数              | $O(1)$             | -                               |
| code8-4.cpp    | 単方向リストの挿入・出力                    | 挿入$O(1)$/出力$O(N)$| リスト状態の出力                |
| code8-5.txt    | 双方向リストのノード定義                    | -                | -                               |
| code8-6.cpp    | 双方向リストの挿入・削除・出力              | 挿入/削除$O(1)$/出力$O(N)$| リスト状態の出力         |
| code8-7.txt    | set/unordered_setの基本操作例               | 挿入/削除/判定$O(1)$～$O(logN)$| -                    |

</details>


